---
title: "Reading text files"
teaching: 0
exercises: 0
questions:
- "What is a data frame?"
- "How can I read a complete csv file into R?"
- "How can I get basic summary information about my dataset?"
- "How can I change the way R treats strings in my dataset?"
- "Why would I want strings to be treated differently?"
- "How are dates represented in R and how can I change the format?"

objectives:
- "Understand what a data frame is"
- "Use read.csv to read a csv file into an R data frame"
- "Examine the structure and contents of a data frame"
- "Differentiate between a factor and a string"
- "Indicate that R should treat strings as factors or treat factors as strings"
- "Examine and change date formats in R"

keypoints:
- "First key point."
---

## Loading a datafile into the R environment

In most practical scenarios you will want to read data into the R environment from a dataset.

RStudio provides an interface for reading a variety of commonly available data formats produced by other commercial statistical packages such as SPSS and Stata.

We will demonstrate this functionality by importing the SN7577 dataset in both the tab delimited (SN7577.tab) and the SPSS (SN7577_spss.sav) formats.

Full details of the SN7577 dataset are available [here]


The import dataset option is available from the toolbar in the environment tab.

![Import Dataset](../fig/R_02_Import_Dataset_01.png)


There is no option to import a tab delimited file so we choose the csv option.

The wizard guides you through selecting a file and allows you to set or change various characteristics of the data.

In our case although we are using the import csv option the file itself is a tab delimitted dataset so we need to change the seperator from ',' to '\t'.
Notice how changing this option makes the 'mess' in the preview pane change to a nicely formatted table structure.

RStudio performs the import by generating valid R code based on your options and copying the code to the console and running it. You can see the code that it will use in the bottom left pane of the Wizard window.

When you click the import button, the dataset is imported. The code used is copied to to the console window and executed.

To import the tab delimitted version of the SN7577 file the following code was produced and ran

~~~
library(readr)
SN7577_tab <- read_delim("SN7577.tab", "\t", escape_double = FALSE, trim_ws = TRUE)
~~~
{: .language-r}

The 'library(readr)' line tells the R environment to import the 'readr' library of functions for use. the `read.delim` function is part of the `readr` library.
The `read_delim()` function is a generalised version of the read_csv(). There are also a `read_tsv` functions which is also derived from `read_delim` and we could have used this directly from the console.

~~~
library(readr)
SN7577_csv <- read_delim("SN7577.tab", "\t")

SN7577_csv <- read_tsv("SN7577.tab")
~~~
{: .language-r
}
> ## Exercise
>
> Use the import dataset wizard to import the SN7577>spss.sav dataset.
> Notice the different library being used.
> Notice that there are far fewer option to play with
>
> When the data is imported, compare it with the SN7577_csv data.
> Can you find two very clear differences in how the data is shown?
> > ## Solution
> >
> > 1. On the csv file the headers are just the question numbers and on the spss file they include the question itself.
> > 2. On the spss file missing data is denoted as NA, however in the csv version missing data is typically shown as -1.
> >
> {: .solution}
{: .challenge}

For the rest of this episode we will focus only the the SN7577_csv version.

When we imported the dataset the wizard automatically include a 'View(SN7577_csv)' line of code. This shows (part of) the contents of the variable as tabular data in a grid in the top pane.

You could also just type the variable name into the console to see the data (or part of it).

If use 'class(SN7577_csv)' to find the type of this cariable, you will see that it appears to have 3 different types.

~~~
class(SN7577_spss)
~~~
{: .language-r}

~~~
[1] "tbl_df"     "tbl"        "data.frame"
~~~
{: .output}

It is the last one "data.frame" that we are going to look art in detail.

## Data frames


Data frames are the de facto data structure for most tabular data, and what we use for statistics and plotting.
A data frame can be created by hand, but most commonly they are generated by the functions read.csv(), read_delim(). read_tsv or read.table(); in other words, when importing external datasets into the R environment.
A data frame is the representation of data in the format of a table, very much as you see in a spreadsheet, where the columns are vectors that all have the same length and are of the same type.

Apart from viewing or partially viewing the data by typing the variable name into the console there are several other functions which can be used to find out bits of information about a dataframe.

~~~
dim(SN7577_csv)        # no of rows and columns
nrow(SN7577_csv)       # number of rows
ncol(SN7577_csv)       # number of columns

head(SN7577_csv)       # shows first 6 rows (but truncates the variables)
tail(SN7577_csv)       # shows last 6 rows (but truncates the variables)

names(SN7577_csv)      # lists all of the column names
names(SN7577_spss)     # Despite the extra text in the 'View' the column names for the spss variable
                       # are the same as the csv version
rownames(SN7577_csv)   # list the column names, esentialy index numbers which we don't really need

str(SN7577_csv)        # Show the overall structure of the variable, similar but more complex to what
                       # what we have seen for other variables.
summary(SN7577_csv)    # displays summary statistics for the different columns.
~~~
{: .language-r}

## Slicing and Dicing a dataframe

Dataframes are 2-dimensional, we describe them as having rows and columns.
If we want to extract some specific data from a dataframe we need to specify the "coordinates"
of the data. We give the row numbers first and then the column numbers. (Unfortunately this is the opposite to Excel, where we normally give the column letter and then the row number)

There are a variety of ways of indicating the rows and columns of interest. How you specify can effect the datatype of the data returned

~~~
SN7577_csv[1, 1]   # first column of the first of the data frame (as a vector)
SN7577_csv[1, 6]   # the 6th column  in first row(as a vector)
SN7577_csv[, 1]    # all of the first column values in the data frame (as a vector)
SN7577_csv[1]      # all of the first column values in the data frame (as a data.frame)
SN7577_csv[1:3, 7] # the 7th column from the first three rows in the dataframe (as a vector)
SN7577_csv[3, ]    # all of the columns in the 3rd row of the dataframe (as a data.frame)
~~~


`:` is a special function that creates numeric vectors of integers in increasing
or decreasing order, test `1:10` and `10:1` for instance.

You can also exclude certain parts of a data frame using the "`-`" sign:

~~~
SN7577_csv[,-1]          # The whole data frame, except the first column
SN7577_csv[-c(7:34786),] # Equivalent to head(surveys)
~~~

As well as using numeric values to subset a `data.frame` (or `matrix`), columns
can be called by name, using one of the four following notations:

~~~
SN7577_csv["Q2"]       # Result is a data.frame
SN7577_csv[, "Q2"]     # Result is a vector
SN7577_csv[["Q2"]]     # Result is a vector
SN7577_csv$Q2          # Result is a vector
~~~

For our purposes, the last three notations are equivalent. Although if you run the code you will notice differences in the display.
RStudio knows about the columns in your data frame, so you can take advantage of the autocompletion
feature to get the full and correct column name


> ## Exercise
>
> 1. Create a `data.frame` (`SN7577_200`) containing only the observations from
>    row 200 of the `SN7577_csv` dataset.
>
> 2. Notice how `nrow()` gave you the number of rows in a `data.frame`?
>
>      * Use that number to pull out just that last row in the data frame.
>      * Compare that with what you see as the last row using `tail()` to make
>        sure it's meeting expectations.
>      * Pull out that last row using `nrow()` instead of the row number.
>      * Create a new data frame object (`surveys_last`) from that last row.
>
> 3. Use `nrow()` to extract the row that is in the middle of the data
>    frame. Store the content of this row in an object named `SN7577_middle`.
>
> 4. Combine `nrow()` with the `-` notation above to reproduce the behavior of
>    `head(SN7577_csv)` keeping just the first through 6th rows of the SN7577_csv
>    dataset.
>
> > ## Solution
> >
> > ~~~
> > SN7577_200 <- SN7577_csv[200, ]
> > SN7577_200
> > SN7577_last <- SN7577_csv[nrow(SN7577_csv), ]
> > SN7577_last
> > SN7577_middle <- SN7577_csv[nrow(SN7577_csv)/2, ]
> > SN7577_middle
> > SN7577_head <- SN7577_csv[-c(7:nrow(SN7577_csv)),]
> > SN7577_head
> > ~~~
> >
> {: .solution}
{: .challenge}


## Factors

Factors are used to represent categorical data. Factors can be ordered or
unordered, and understanding them is necessary for statistical analysis and for
plotting.

Although the mjority of the data in the SN7577_csv is in fact categorical data, as it has all been represented as numerical values, using it to discuss Factors would be confusing. So instead we wil load a copy of our SAFI dataset and use that .

~~~
SAFI_results <- read_csv("SAFI_results.csv")
~~~

Initially the dataset is loaded without any Factors, all the the string like columns as defined as characters.

~~~
str(SAFI_results$C01_respondent_roof_type)
str(SAFI_results$C02_respondent_wall_type)
str(SAFI_results$C03_respondent_floor_type)
~~~

You can see from the output of the 'str' functions that these columns appear to have only a few different string values, suggesting that they are better considered categorical.

We can explicitly change them from characters to Factors using the 'as.factor' function.

~~~
SAFI_results$C01_respondent_roof_type <- as.factor(SAFI_results$C01_respondent_roof_type)
SAFI_results$C02_respondent_wall_type <- as.factor(SAFI_results$C02_respondent_wall_type)
SAFI_results$C03_respondent_floor_type <- as.factor(SAFI_results$C03_respondent_floor_type)

str(SAFI_results$C01_respondent_roof_type)
str(SAFI_results$C02_respondent_wall_type)
str(SAFI_results$C03_respondent_floor_type)
~~~

(If you wanted to convert a string Factor to a character string, you can use the 'as.character' function.)

Notice the output of the 'str' function. It tells you how many 'levels' (unique values) there are, what they are, although this is usally truncated, and which rows have which level.

This last point may not be obvious as all you see isa list of integers.
When the Factors are created, they are stored in alphabetical order and allocated an integer value starting at one for the first and so on. It is these integers values that you see displayed, one per record, that you see displayed at the end of the 'str' output. Again this is normally truncated.

For any Factor, apart from using 'str' , you can find out how many levels there are and what they are called like this

~~~
nlevels(SAFI_results$C02_respondent_wall_type)
levels(SAFI_results$C02_respondent_wall_type)
~~~

Sometimes, the order of the factors does not matter, other times you might want
to specify the order because it is meaningful (e.g., "low", "medium", "high"),
it improves your visualization, or it is required by a particular type of
analysis. Here, one way to reorder our levels in the `sex` vector would be

~~~
levels(SAFI_results$C02_respondent_wall_type)   # before

SAFI_results$C02_respondent_wall_type <- factor(SAFI_results$C02_respondent_wall_type,
                                      levels = c("muddaub", "sunbricks", "burntbricks", "cement"))

levels(SAFI_results$C02_respondent_wall_type)   # after
~~~

### Plotting factors

When your data is stored as a factor, you can use the `plot()` function to get a
quick glance at the number of observations represented by each factor
level.

~~~
## bar plot of the different roof types:
plot(SAFI_results$C01_respondent_roof_type)
~~~

The bar chart plot appears in the plots pane. In this case there are the expected 3 bars one for each differnet roof type. Using simple plots like this gives a quick indication of the spread of the data.


## Formatting Dates

One of the most common issues that new (and experienced!) R users have is
converting date and time information into a variable that is appropriate and
usable during analyses. As a reminder from the Excel lesson when we spoke about dates, one good practice for dealing with date data is to ensure that each component of your date is stored as a separate variable.

In the SAFI_results dataset, we have three date fields

A01_interview_date
A04_start
A05_end

If we look at the structure of these fields

~~~
str(SAFI_results$A01_interview_date)
str(SAFI_results$A04_start)
str(SAFI_results$A05_end)
~~~

we cann see that the first is a character string and the other two are of a type called POSIXct, but they look like stings. As humans we have no difficulty in reading the dates and date/times. To get a computer to read them we need to be a bit more specific about the layout.

Although it is clear that when R imported the SAFI_results datasets it was able to recognise the last two as date formats.

What we want to do is to extract the various parts of the date and time from these fields so as to create seperate fields for the dy month and year. We will use the A04_start column as an example.

To make this job very easy, we are going to use the functions provided by a library called 'lubridate'. This library is part of the 'tidyverse' library, so if you have installed 'tidyverse' it will be available.

Within this library there are a set of appropriately named functions to extract date and time parts.

~~~

year(as.POSIXct(SAFI_results$A04_start, format="%Y-%m-%d %H:%M:%S"))
month(as.POSIXct(SAFI_results$A04_start, format="%Y-%m-%d %H:%M:%S"))
day(as.POSIXct(SAFI_results$A04_start, format="%Y-%m-%d %H:%M:%S"))
hour(as.POSIXct(SAFI_results$A04_start, format="%Y-%m-%d %H:%M:%S"))
minute(as.POSIXct(SAFI_results$A04_start, format="%Y-%m-%d %H:%M:%S"))
second(as.POSIXct(SAFI_results$A04_start, format="%Y-%m-%d %H:%M:%S"))

~~~

Although A04_start has been recognised as a POSIXct type, we still use the 'as.POSIXCT' function because we need to specify the format that the date field is in. Trying to coerce a type into a type it already is, doesn't cause an error.

The tricky part is getting the format string right. The '%' indicates that the next character has special meaning, other characters represent themselves. Just looking at the special characters we have used, given that you know what the data looks like it is quite straight forward to workout what each letter represents. You can find a comprehennsive list by looking at the help page for 'as.POSIXct' (?as.POSIXct in the console)

Having split the components out we can add them as new columns to the SAFI_results dataframe.

~~~
SAFI_results$A04_year <- year(as.POSIXct(SAFI_results$A04_start, format="%Y-%m-%d %H:%M:%S"))
SAFI_results$A04_month <- month(as.POSIXct(SAFI_results$A04_start, format="%Y-%m-%d %H:%M:%S"))
SAFI_results$A04_day <- day(as.POSIXct(SAFI_results$A04_start, format="%Y-%m-%d %H:%M:%S"))
SAFI_results$A04_hour <- hour(as.POSIXct(SAFI_results$A04_start, format="%Y-%m-%d %H:%M:%S"))
SAFI_results$A04_minute <- minute(as.POSIXct(SAFI_results$A04_start, format="%Y-%m-%d %H:%M:%S"))
SAFI_results$A04_second <- second(as.POSIXct(SAFI_results$A04_start, format="%Y-%m-%d %H:%M:%S"))
View(SAFI_results)
~~~

> ## Exercise
>
> Use appropriate functions from lubridate to add three new columns to the SAFI_results dataframe representing the
> day, month and year of the A01_interview_date column
>
> > ## Solution
> >
> > ~~~
> > SAFI_results$A01_year <- year(as.POSIXct(SAFI_results$A01_interview_date,format="%d/%m/%Y"))
> > SAFI_results$A01_month <- month(as.POSIXct(SAFI_results$A01_interview_date,format="%d/%m/%Y"))
> > SAFI_results$A01_day <- day(as.POSIXct(SAFI_results$A01_interview_date,format="%d/%m/%Y"))
> > ~~~
> >
> {: .solution}
{: .challenge}


If we want to go the other way, that is combine seperate components into a date format, we can do that as well.

Again using functions from 'lubridate'

~~~

my_date <- ymd("2018-01-29")
str(my_date)

my_date <- dmy("30-01-2018")
str(my_date)

my_date <- mdy("01-31-2018")
str(my_date)

~~~

we can create dates in a variety of formats.

To combine our seperate components we can use the 'paste' function. We need to choose the lubridate function which matches the order in which we have concateneated the individual components and finally just to make it interesting we will move the date to the following day by simply adding 1 to it.


~~~
SAFI_results$A01_next_day <-  1 + dmy(paste(SAFI_results$A01_day, SAFI_results$A01_month, SAFI_results$A01_year, sep = '-'))
~~~
