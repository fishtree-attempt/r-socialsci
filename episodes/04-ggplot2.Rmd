---
title: "Data visualisation with ggplot2"
teaching: 45
exercises: 20
questions:
- "What are the components of a ggplot?"
- "How do I create scatterplots, boxplots, and barplots?"
- "How can I change the aesthetics (ex. colour, transparency) of my plot?"
- "How can I create multiple plots at once?"
objectives:
- "Produce scatter plots, boxplots, and time series plots using ggplot.
- "Set universal plot settings."
- "Describe what faceting is and apply faceting in ggplot."
- "Modify the aesthetics of an existing ggplot plot (including axis labels and color)."
- "Build complex and customized plots from data in a data frame."
keypoints:
- "`ggplot2` is a flexible and useful tool for creating plots in R."
- "The data set and coordinate system can be defined using the `ggplot` function."
- "Additional layers, including geoms, are added using the `+` operator."
- "Boxplots are useful for visualizing the distribuion of a continuous variable."
- "Barplot are useful for visualizing categorical data."
- "Facetting allows you to generate multiple plots based on a categorical variable."
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("04-")
```

We start by loading the required packages. **`ggplot2`** is included in the **`tidyverse`** package.

```{r load-package, message=FALSE, purl=FALSE}
library(tidyverse)
```

If not still in the workspace, load the data we saved in the previous lesson.


```{r load-data, eval=FALSE, purl=FALSE}
interviews_plotting <- read_csv("data_output/interviews_plotting.csv")

```
## Plotting with **`ggplot2`**

**`ggplot2`** is a plotting package that makes it simple to create complex plots
from data in a data frame. It provides a more programmatic interface for
specifying what variables to plot, how they are displayed, and general visual
properties. Therefore, we only need minimal changes if the underlying data change
or if we decide to change from a bar plot to a scatterplot. This helps in creating
publication quality plots with minimal amounts of adjustments and tweaking.

**`ggplot2`** functions like data in the 'long' format, i.e., a column for every dimension,
and a row for every observation. Well-structured data will save you lots of time
when making figures with **`ggplot2`**

ggplot graphics are built step by step by adding new elements. Adding layers in
this fashion allows for extensive flexibility and customization of plots.

To build a ggplot, we will use the following basic template that can be used for different types of plots:

ggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) +  <GEOM_FUNCTION>()

- use the `ggplot()` function and bind the plot to a specific data frame using the
`data` argument

```{r, eval=FALSE, purl=FALSE}
ggplot(data = interviews_plotting)
```
- define a mapping (using the aesthetic (`aes`) function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, color, etc.

```{r, eval=FALSE, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items))
```

- add 'geoms' â€“ graphical representations of the data in the plot (points,
lines, bars). **`ggplot2`** offers many different geoms; we will use some
common ones today, including:

* `geom_point()` for scatter plots, dot plots, etc.
* `geom_boxplot()` for, well, boxplots!
* `geom_line()` for trend lines, time series, etc.

To add a geom to the plot use the `+` operator. Because we have two continuous variables,
let's use `geom_point()` first:

```{r first-ggplot, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
geom_point()
```
The `+` in the **`ggplot2`** package is particularly useful because it allows you
to modify existing `ggplot` objects. This means you can easily set up plot
templates and conveniently explore different types of plots, so the above
plot can also be generated with code like this:

```{r, first-ggplot-with-plus, eval=FALSE, purl=FALSE}
# Assign plot to a variable
interviews_plot <- ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items))

# Draw the plot
interviews_plot +
geom_point()
```

**Notes**

- Anything you put in the `ggplot()` function can be seen by any geom layers
that you add (i.e., these are universal plot settings). This includes the x- and
y-axis mapping you set up in `aes()`.
- You can also specify mappings for a given geom independently of the
mappings defined globally in the `ggplot()` function.
- The `+` sign used to add new layers must be placed at the end of the line containing
the *previous* layer. If, instead, the `+` sign is added at the beginning of the line
containing the new layer, **`ggplot2`** will not add the new layer and will return an
error message.

```{r, ggplot-with-plus-position, eval=FALSE, purl=FALSE}
# This is the correct syntax for adding layers
interviews_plot +
geom_point()

# This will not add the new layer and will return an error message
interviews_plot
+ geom_point()
```

## Building your plots iteratively

Building plots with **`ggplot2`** is typically an iterative process. We start by
defining the dataset we'll use, lay out the axes, and choose a geom:

```{r create-ggplot-object, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
geom_point()
```

Then, we start modifying this plot to extract more information from it. For
instance, we can add transparency (`alpha`) to avoid overplotting:

```{r adding-transparency, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
geom_point(alpha = 0.5)
```

That only helped a little bit with the overplotting problem. We can also
introduce a little bit of randomness into the position of our points
using the `geom_jitter()` function.

```{r adding-jitter, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
geom_jitter(alpha = 0.5)
```


We can also add colors for all the points:

```{r adding-colors, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
geom_jitter(alpha = 0.5, color = "blue")
```

Or to color each species in the plot differently, you could use a vector as an input to the argument **color**. **`ggplot2`** will provide a different color corresponding to different values in the vector. Here is an example where we color by **`village`**:


```{r color-by-species, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
geom_jitter(aes(alpha = 0.5, color = village))
```

There appears to be a positive trend between number of household
members and number of items owned (from the list provided). This trend
does not appear to be different by village.

> ## Exercise
>
> Use what you just learned to create a scatter plot of `rooms` by
> `village` with the `respondent_wall_type` showing in different colors. Is this a good
> way to show this type of data?
>
> > ## Solution
> > ```{r scatter-challenge, answer=TRUE, purl=FALSE}
> > ggplot(data = interviews_plotting, aes(x = village, y = rooms)) +
> > geom_jitter(aes(color = respondent_wall_type))
> > ```
> {: .solution}
{: .challenge}


## Boxplot

We can use boxplots to visualize the distribution of rooms for each
wall type:

```{r boxplot, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = respondent_wall_type, y = rooms)) +
geom_boxplot()
```

By adding points to a boxplot, we can have a better idea of the number of
measurements and of their distribution:

```{r boxplot-with-points, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = respondent_wall_type, y = rooms)) +
geom_boxplot(alpha = 0) +
geom_jitter(alpha = 0.5, color = "tomato")
```

We can see that muddaub houses and sunbrick houses tend to be smaller than
burntbrick houses.

Notice how the boxplot layer is behind the jitter layer? What do you need to
change in the code to put the boxplot in front of the points such that it's not
hidden?

> ## Exercise
>
> Boxplots are useful summaries, but hide the *shape* of the distribution. For
> example, if the distribution is bimodal, we would not see it in a
> boxplot. An alternative to the boxplot is the violin plot, where the shape
(of the density of points) is drawn.
>
> - Replace the box plot with a violin plot; see `geom_violin()`.
> > ## Solution
> > ```{r}
> > ggplot(data = interviews_plotting, aes(x = respondent_wall_type, y = rooms)) +
> > geom_violin(alpha = 0) +
> > geom_jitter(alpha = 0.5, color = "tomato")
> > ```
> {: .solution}
>
> So far, we've looked at the distribution of room number within wall type. Try making a
> new plot to explore the distribution of another variable within wall type.
>
> - Create a boxplot for `liv_count` for each wall type. Overlay the boxplot layer on a jitter
>   layer to show actual measurements.
>
> > ## Solution
> > ggplot(data = interviews_plotting, aes(x = respondent_wall_type, y = liv_count)) +
> > geom_boxplot(alpha = 0) +
> > geom_jitter(alpha = 0.5)
> {: .solution}
>
> - Add color to the data points on your boxplot according to whether
> the respondent is a member of an irrigation association (`memb_assoc`).
>
> > ## Solution
> > ggplot(data = interviews_plotting, aes(x = respondent_wall_type, y = liv_count)) +
> > geom_boxplot(alpha = 0) +
> > geom_jitter(aes(alpha = 0.5, color = memb_assoc))
> {: .solution}

## Barplots

Barplots are also useful for visualizing categorical data. By default,
`geom_bar` accepts a variable for x, and plots the number of instances 
each value of x (in this case, wall type) appears in the dataset.

```{r}
ggplot(data = interviews_plotting, aes(x = respondent_wall_type)) +
geom_bar()
```




```{r}
ggplot(data = interviews_plotting, aes(x = respondent_wall_type)) +
geom_bar(aes(fill = village), position = "dodge")
```




```{r}
percent_wall_type <- interviews_plotting %>%
filter(respondent_wall_type != "cement") %>%
group_by(respondent_wall_type, village) %>%
summarize(count = n()) %>%
mutate(percent = count / sum(count))

ggplot(percent_wall_type, aes(x = village, y = percent, fill = respondent_wall_type)) +
geom_bar(stat = "identity", position = "dodge")
```









## Adding Labels and Titles

By default, the axes labels are determined by the name of the variable 
being plotted. However, `ggplot2` offers lots of cusomization options, 
like specifing the axes labels, and adding a title to the plot with 
relatively little code.

```{r}
ggplot(data=SAFI_results, aes(x=factor(C02_respondent_wall_type))) +
  geom_bar() +
  ylab("Frequency") +  
  xlab("Wall Type") +
  ggtitle("Frequency of SAFI Building Wall Types")
```

> ## Exercise
>
> Create a barplot of the number of records for each type of roof (`C01_respondent_roof_type`).
> Create a barplot of the average number of plots of each village.
> Provide suitable axes labels and titles for each.
>
> > ## Solution
> >
> > ```{r}
> > ggplot(data = SAFI_results, aes(x = C01_respondent_roof_type)) +
> >   geom_bar() +
> >   xlab("Roof Type") +
> >   ylab("Frequency") +
> >   ggtitle("Frequency of SAFI Building Roof Types")
> >
> > plots_avs <- SAFI_results %>%
> >   group_by(A09_village) %>%
> >   summarise(av=mean(D_plots_count))
> >
> > ggplot(data = plots_avs, aes(x = A09_village, y=av)) +
> >   geom_bar(stat="identity") +
> >   xlab("Village") +
> >   ylab("Average Number of Plots") +
> >   ggtitle("Average Number of Plots by Village")
> > ```
> >
> {: .solution}
{: .challenge}

## Faceting

What if, instead of wanting to visualize the frequency of wall types across 
the entire data set, we wanted to visualize the frequency of wall types by 
village? One method to do this would be to make a subset of the 
data for each village and create a plot for each individual subset. But, 
this would likely be tedious and time-consuming.

Instead, `ggplot2` has a built-in method of doing this, called *facetting*. The 
`facet_wrap` function allows the user to split one plot into multiple plots 
based on a factor included in the dataset.

We'll use this to create a barplot for each village.

```{r}
ggplot(data = SAFI_results, aes(x = C02_respondent_wall_type)) +
    geom_bar() +
    ylab("Frequency") +  
    xlab("wall Type") +
    ggtitle("Frequency of SAFI Building Wall Types by Village") +
  facet_wrap(~ A09_village )
```

> ## Exercise
>
> Create a facetted set of plots which show the different the different villages use differnet
> roof types (`C01_respondent_roof_type`) 
> 
> For an extra challenge, try to create a facetted set of barplots of the average
> household size by roof type and village.>
> > ## Solution
> >
> > ```{r}
> > ggplot(data = SAFI_results, aes(x = C01_respondent_roof_type)) +
> >   geom_bar() +
> >   ylab("Frequency") +  
> >   xlab("Roof Type") +
> >   ggtitle("Frequency of SAFI Building Roof Types by Village") +
> >   facet_wrap(~ A09_village)
> >
> > # Challenge Solution:
> > size_avs <- SAFI_results %>%
> >   group_by(A09_village, C01_respondent_roof_type) %>%
> >   summarise(av = mean(B_no_membrs))
> >
> > ggplot(size_avs, aes(x = C01_respondent_roof_type, y = av)) +
> >   geom_bar(stat = "identity") +
> >   xlab("Roof Type") +
> >   ylab("Average Household Size") +
> >   ggtitle("Average Household Size with Each Roof Type, by Village") +
> >   facet_wrap(~ A09_village)
> > ```
> >
> {: .solution}
{: .challenge}

