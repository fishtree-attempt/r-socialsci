---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit ignore-05-databases.md in _episodes_rmd/
title: "Using a relational database with R"
teaching: 0
exercises: 0
questions:
- "How can I import data held in an SQLite database into an R data frame?"
- "How can I write data from a data frame to an SQLite table?"
- "How can I create an SQLite database from csv files"

objectives:
- "Install RSQLite package"
- "Create a connection to an SQLite database"
- "Query the database"
- "Create a new databaseand populate it"
- "Use dplyr functions to access and query an SQLite database"

keypoints:
- "First key point."
---





## Introduction

A common problem with R in that all operations are conducted in-memory and thus
the amount of data you can work with is limited by available memory. So far, we have used small datasets
that can easily fit into your computer's memory. But what about datasets that are too large for your
computer to handle as a whole?

In this case, it is helpful to organze the data into a database stored outside of R before creating
a connection to the database itself. This connection will essentially remove the limitation of memory
because SQL queries can be sent directly from R to the database and return to R only the results that you
have identified as being neccessary for your analysis.

Once we have made the connection to the database, much of what we do will look familiar because the code we will be using is very similar to what we saw in the SQL lesson and earlier episodes of this R lesson.

In this lesson, we will be connecting to an SQLite database, which allows us to send strings containing SQL statements directly from R to the database and recieve the results. In addition, we will be connecting to the database in such a way that we can use 'dplyr' functions to operate directly on the database tables.


## Prelminaries

First, install and load the neccessary packages. You can install the `RSQLite` package with



~~~
install.packages("RSQLite")
~~~
{: .language-r}

Load the packages with


~~~
library(RSQLite)
~~~
{: .language-r}



~~~
Error in library(RSQLite): there is no package called 'RSQLite'
~~~
{: .error}



~~~
library(dplyr)
~~~
{: .language-r}

Next, create a variable that contains the location of the SQLite database we are going to use. Here, we are assuming that it is in the current working directory.


~~~
dbfile <- "data/SN7577.sqlite"
~~~
{: .language-r}

## Connecting to an SQLite Database

Connect to the SQLite database specified by `dbfile`, above, using the `dbConnect` function.


~~~
mydb <- dbConnect(dbDriver("SQLite"), dbfile)
~~~
{: .language-r}



~~~
Error in dbConnect(dbDriver("SQLite"), dbfile): could not find function "dbConnect"
~~~
{: .error}

Here, `mydb` represents the connection to the database. It will be specified every time we need to access the database.

Now that we have a connection, we can get a list of the tables in the database.


~~~
dbListTables(mydb)
~~~
{: .language-r}



~~~
Error in dbListTables(mydb): could not find function "dbListTables"
~~~
{: .error}

Our objective here is to bring data from the database into R by sending a query to the database and then asking for the results of that query.


~~~
# Assign the results of a SQL query to an SQLiteResult object
results <- dbSendQuery(mydb, "SELECT * FROM Question1")
~~~
{: .language-r}



~~~
Error in dbSendQuery(mydb, "SELECT * FROM Question1"): could not find function "dbSendQuery"
~~~
{: .error}



~~~
# Return results from a custom object to a dataframe
data <- fetch(results)
~~~
{: .language-r}



~~~
Error in fetch(results): could not find function "fetch"
~~~
{: .error}

`data` is a standard R dataframe that can be explored and manipulated.


~~~
# Return column names
names(data)
~~~
{: .language-r}



~~~
NULL
~~~
{: .output}



~~~
# Return description of dataframe structure
str(data)
~~~
{: .language-r}



~~~
function (..., list = character(), package = NULL, lib.loc = NULL, 
    verbose = getOption("verbose"), envir = .GlobalEnv)  
~~~
{: .output}



~~~
# Return the second column
data[,2]
~~~
{: .language-r}



~~~
Error in data[, 2]: object of type 'closure' is not subsettable
~~~
{: .error}



~~~
# Return the value of the second column, fourth row
data[4,2]
~~~
{: .language-r}



~~~
Error in data[4, 2]: object of type 'closure' is not subsettable
~~~
{: .error}



~~~
# Return the second column where the value of the column 'key' is greater than 7
data[data$key > 7,2]
~~~
{: .language-r}



~~~
Error in data$key: object of type 'closure' is not subsettable
~~~
{: .error}

Once you have retrieved the data you should close the connection.


~~~
dbClearResult(results)
~~~
{: .language-r}



~~~
Error in dbClearResult(results): could not find function "dbClearResult"
~~~
{: .error}

In addition to sending simple queries we can send complex one like a join.
You may want to set this up in a concateneted string first for readability.


~~~
SQL_query <- paste("SELECT q.value,",
                   "count(*) as how_many",
                   "FROM SN7577 s",
                   "JOIN Question1  q",
                   "ON q.key = s.Q1",
                   "GROUP BY  s.Q1")

results <- dbSendQuery(mydb, SQL_query)
~~~
{: .language-r}



~~~
Error in dbSendQuery(mydb, SQL_query): could not find function "dbSendQuery"
~~~
{: .error}



~~~
data <- fetch(results)
~~~
{: .language-r}



~~~
Error in fetch(results): could not find function "fetch"
~~~
{: .error}



~~~
data
~~~
{: .language-r}



~~~
function (..., list = character(), package = NULL, lib.loc = NULL, 
    verbose = getOption("verbose"), envir = .GlobalEnv) 
{
    fileExt <- function(x) {
        db <- grepl("\\\\.[^.]+\\\\.(gz|bz2|xz)$", x)
        ans <- sub(".*\\\\.", "", x)
        ans[db] <- sub(".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$", "\\\\1\\\\2", 
            x[db])
        ans
    }
    names <- c(as.character(substitute(list(...))[-1L]), list)
    if (!is.null(package)) {
        if (!is.character(package)) 
            stop("'package' must be a character string or NULL")
        if (any(package %in% "base")) 
            warning("datasets have been moved from package 'base' to package 'datasets'")
        if (any(package %in% "stats")) 
            warning("datasets have been moved from package 'stats' to package 'datasets'")
        package[package %in% c("base", "stats")] <- "datasets"
    }
    paths <- find.package(package, lib.loc, verbose = verbose)
    if (is.null(lib.loc)) 
        paths <- c(path.package(package, TRUE), if (!length(package)) getwd(), 
            paths)
    paths <- unique(normalizePath(paths[file.exists(paths)]))
    paths <- paths[dir.exists(file.path(paths, "data"))]
    dataExts <- tools:::.make_file_exts("data")
    if (length(names) == 0L) {
        db <- matrix(character(), nrow = 0L, ncol = 4L)
        for (path in paths) {
            entries <- NULL
            packageName <- if (file_test("-f", file.path(path, 
                "DESCRIPTION"))) 
                basename(path)
            else "."
            if (file_test("-f", INDEX <- file.path(path, "Meta", 
                "data.rds"))) {
                entries <- readRDS(INDEX)
            }
            else {
                dataDir <- file.path(path, "data")
                entries <- tools::list_files_with_type(dataDir, 
                  "data")
                if (length(entries)) {
                  entries <- unique(tools::file_path_sans_ext(basename(entries)))
                  entries <- cbind(entries, "")
                }
            }
            if (NROW(entries)) {
                if (is.matrix(entries) && ncol(entries) == 2L) 
                  db <- rbind(db, cbind(packageName, dirname(path), 
                    entries))
                else warning(gettextf("data index for package %s is invalid and will be ignored", 
                  sQuote(packageName)), domain = NA, call. = FALSE)
            }
        }
        colnames(db) <- c("Package", "LibPath", "Item", "Title")
        footer <- if (missing(package)) 
            paste0("Use ", sQuote(paste("data(package =", ".packages(all.available = TRUE))")), 
                "\\n", "to list the data sets in all *available* packages.")
        else NULL
        y <- list(title = "Data sets", header = NULL, results = db, 
            footer = footer)
        class(y) <- "packageIQR"
        return(y)
    }
    paths <- file.path(paths, "data")
    for (name in names) {
        found <- FALSE
        for (p in paths) {
            if (file_test("-f", file.path(p, "Rdata.rds"))) {
                rds <- readRDS(file.path(p, "Rdata.rds"))
                if (name %in% names(rds)) {
                  found <- TRUE
                  if (verbose) 
                    message(sprintf("name=%s:\\t found in Rdata.rds", 
                      name), domain = NA)
                  thispkg <- sub(".*/([^/]*)/data$", "\\\\1", p)
                  thispkg <- sub("_.*$", "", thispkg)
                  thispkg <- paste0("package:", thispkg)
                  objs <- rds[[name]]
                  lazyLoad(file.path(p, "Rdata"), envir = envir, 
                    filter = function(x) x %in% objs)
                  break
                }
                else if (verbose) 
                  message(sprintf("name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n", 
                    name, paste(names(rds), collapse = ",")), 
                    domain = NA)
            }
            if (file_test("-f", file.path(p, "Rdata.zip"))) {
                warning("zipped data found for package ", sQuote(basename(dirname(p))), 
                  ".\\nThat is defunct, so please re-install the package.", 
                  domain = NA)
                if (file_test("-f", fp <- file.path(p, "filelist"))) 
                  files <- file.path(p, scan(fp, what = "", quiet = TRUE))
                else {
                  warning(gettextf("file 'filelist' is missing for directory %s", 
                    sQuote(p)), domain = NA)
                  next
                }
            }
            else {
                files <- list.files(p, full.names = TRUE)
            }
            files <- files[grep(name, files, fixed = TRUE)]
            if (length(files) > 1L) {
                o <- match(fileExt(files), dataExts, nomatch = 100L)
                paths0 <- dirname(files)
                paths0 <- factor(paths0, levels = unique(paths0))
                files <- files[order(paths0, o)]
            }
            if (length(files)) {
                for (file in files) {
                  if (verbose) 
                    message("name=", name, ":\\t file= ...", .Platform$file.sep, 
                      basename(file), "::\\t", appendLF = FALSE, 
                      domain = NA)
                  ext <- fileExt(file)
                  if (basename(file) != paste0(name, ".", ext)) 
                    found <- FALSE
                  else {
                    found <- TRUE
                    zfile <- file
                    zipname <- file.path(dirname(file), "Rdata.zip")
                    if (file.exists(zipname)) {
                      Rdatadir <- tempfile("Rdata")
                      dir.create(Rdatadir, showWarnings = FALSE)
                      topic <- basename(file)
                      rc <- .External(C_unzip, zipname, topic, 
                        Rdatadir, FALSE, TRUE, FALSE, FALSE)
                      if (rc == 0L) 
                        zfile <- file.path(Rdatadir, topic)
                    }
                    if (zfile != file) 
                      on.exit(unlink(zfile))
                    switch(ext, R = , r = {
                      library("utils")
                      sys.source(zfile, chdir = TRUE, envir = envir)
                    }, RData = , rdata = , rda = load(zfile, 
                      envir = envir), TXT = , txt = , tab = , 
                      tab.gz = , tab.bz2 = , tab.xz = , txt.gz = , 
                      txt.bz2 = , txt.xz = assign(name, read.table(zfile, 
                        header = TRUE, as.is = FALSE), envir = envir), 
                      CSV = , csv = , csv.gz = , csv.bz2 = , 
                      csv.xz = assign(name, read.table(zfile, 
                        header = TRUE, sep = ";", as.is = FALSE), 
                        envir = envir), found <- FALSE)
                  }
                  if (found) 
                    break
                }
                if (verbose) 
                  message(if (!found) 
                    "*NOT* ", "found", domain = NA)
            }
            if (found) 
                break
        }
        if (!found) 
            warning(gettextf("data set %s not found", sQuote(name)), 
                domain = NA)
    }
    invisible(names)
}
<bytecode: 0x7fb055613230>
<environment: namespace:utils>
~~~
{: .output}



~~~
dbClearResult(results)
~~~
{: .language-r}



~~~
Error in dbClearResult(results): could not find function "dbClearResult"
~~~
{: .error}

> ## Exercise
>
> What happens if you send invalid SQL syntax?
>
> > ## Solution
> >
> > An error message is returned from SQLite.
> > Notice that R is just the conduit; it cannot check the SQL syntax.
> >
> >
> {: .solution}
{: .challenge}

We can also create a new database and add tables to it. Let's base this new dataframe on the Question1 table that can be found in our existing database.


~~~
# First, use a SQL query to extract the Question1 table from the existing database
results = dbSendQuery(mydb, "SELECT * from Question1")
~~~
{: .language-r}



~~~
Error in dbSendQuery(mydb, "SELECT * from Question1"): could not find function "dbSendQuery"
~~~
{: .error}



~~~
# Then, store it as a dataframe
Q1 <- fetch(results)
~~~
{: .language-r}



~~~
Error in fetch(results): could not find function "fetch"
~~~
{: .error}

Now, we can create the new database and add data to it, either from an external file or a local dataframe.


~~~
dbfile_new = "data/a_newdb.sqlite"
mydb_new = dbConnect(dbDriver("SQLite"), dbfile_new)
~~~
{: .language-r}



~~~
Error in dbConnect(dbDriver("SQLite"), dbfile_new): could not find function "dbConnect"
~~~
{: .error}



~~~
dbWriteTable(conn = mydb_new , name = "SN7577", value = "data/SN7577.csv",
             row.names = FALSE, header = TRUE)
~~~
{: .language-r}



~~~
Error in dbWriteTable(conn = mydb_new, name = "SN7577", value = "data/SN7577.csv", : could not find function "dbWriteTable"
~~~
{: .error}



~~~
dbWriteTable(conn = mydb_new , name = "Q1", value = Q1,
             row.names = FALSE)
~~~
{: .language-r}



~~~
Error in dbWriteTable(conn = mydb_new, name = "Q1", value = Q1, row.names = FALSE): could not find function "dbWriteTable"
~~~
{: .error}



~~~
dbListTables(mydb_new)
~~~
{: .language-r}



~~~
Error in dbListTables(mydb_new): could not find function "dbListTables"
~~~
{: .error}

## Connecting to a Database for `dplyr` Use

When we want to use `dplyr` functions to operate directly on the database tables,
a different connection method is used.


~~~
mydb_dplyr <- src_sqlite(path="data/SN7577.sqlite")
~~~
{: .language-r}



~~~
Error: The dbplyr package is required to communicate with database backends.
~~~
{: .error}

as is the mthod for running queries. However using the 'tbl' functionwe still need to provide avalid SQL string. (?)


~~~
tbl(mydb_dplyr, sql("SELECT count(*) from SN7577"))
~~~
{: .language-r}



~~~
Error in tbl(mydb_dplyr, sql("SELECT count(*) from SN7577")): object 'mydb_dplyr' not found
~~~
{: .error}

The real advantage of using `dplyr` is that once we have stored the table as an object
(here, `SN7577_d`), we can use `dplyr` functions instead of SQL statements.


~~~
# Store the table as an object
SN7577_d <- tbl(mydb_dplyr, sql("SELECT * FROM SN7577"))
~~~
{: .language-r}



~~~
Error in tbl(mydb_dplyr, sql("SELECT * FROM SN7577")): object 'mydb_dplyr' not found
~~~
{: .error}



~~~
# Explore the object
head(SN7577_d, n = 10)
~~~
{: .language-r}



~~~
Error in head(SN7577_d, n = 10): object 'SN7577_d' not found
~~~
{: .error}



~~~
nrow(SN7577_d)
~~~
{: .language-r}



~~~
Error in nrow(SN7577_d): object 'SN7577_d' not found
~~~
{: .error}



~~~
# Apply dplyr functions to the object
SN7577_d %>%
  filter(numage > 60) %>%
  select(sex, age, numage) %>%
  group_by(sex, age) %>%
  summarize(avg_age = mean(numage))
~~~
{: .language-r}



~~~
Error in eval(lhs, parent, parent): object 'SN7577_d' not found
~~~
{: .error}

Notice that on the `nrow` command we get NA rather than a count of rows. Thisis because `dplyr` doesn't hold the full table even after the 'Select * ...'

If you need the row count you can use


~~~
SN7577_d %>%
  tally()
~~~
{: .language-r}



~~~
Error in eval(lhs, parent, parent): object 'SN7577_d' not found
~~~
{: .error}

> ## Exercise
>
> Store the SN7577 table as an object for `dplyr` use.
>
> Write a query using `dplyr` functions that will return the average age (`numage`) by sex for all records where
> the response for Q2 is missing (missing values are indicated by a value of -1).
>
> > ## Solution
> >
> > 
> > ~~~
> > SN7577_d <- tbl(mydb_dplyr, sql("SELECT * FROM SN7577"))
> > > >
> > SN7577_d %>%
> >   filter(Q2 == -1)   %>%
> >   group_by(sex)   %>%
> >   summarize(avg_age = mean(numage))
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > Error: <text>:2:1: unexpected '>'
> > 1: SN7577_d <- tbl(mydb_dplyr, sql("SELECT * FROM SN7577"))
> > 2: >
> >    ^
> > ~~~
> > {: .error}
> >
> {: .solution}
{: .challenge}
